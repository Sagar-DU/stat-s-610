---
title: "STAT-S 610 Homework 4"
author: "Nahid Hasan Sagar"
date: "2025-09-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Question 1
Get the data using `td <- readRDS('tornadoes.RDS')`

```{r}
  td <- readRDS("../tornadoes.RDS")
  head(td)
```

## Question 2
Use `lapply` or `sapply` and the `typeof` function to get the classes of all of the columns of `td`. What happens when you use `lapply` or `sapply` on a data frame? Why?

```{r}
  # Using `lapply` to get the type of each column
  col_types_lapply <- lapply(td, typeof)
  col_types_lapply
```

`lapply(td, typeof)` returned a list. Each element of the list corresponds to one column in `td`, showing the columnâ€™s storage type.
  
```{r}  
  # Using `sapply` to get the type of each column
  col_types_sapply <- sapply(td, typeof)
  col_types_sapply
```

`sapply(td, typeof)` returned a character vector. Since all results were character strings, `sapply` simplified the list into a more compact vector format.

**Why the difference?**

`lapply` always keeps the output as a list. `sapply` attempts to simplify the output into the simplest possible data structure (vector, matrix, or array) when it can.

## Question 3
Using the `split`/`apply`/`combine` strategy discussed in class, compute the fraction of tornadoes with magnitude (`mag`) greater than or equal to 3 for each state. Remember that the previous part showed that magnitude is of type character and you will need to make it into a number.

```{r}
  names(td)
  td$mag_nam <- as.numeric(td$mag)
  mag_greater_3 <- tapply(X = td$mag_nam >=3, INDEX = td$st, FUN = sum)
  mag_greater_3
  total <- tapply(td$mag_nam, INDEX = td$st, FUN = length)
  total
  (mag_greater_3/total)*100
```

### Chat-GPT's response

```{r}
# Convert mag to numeric (you've done this)
td$mag_nam <- as.numeric(td$mag)

# Apply split/apply/combine strategy
mag_greater_3 <- tapply(td$mag_nam >= 3, td$st, FUN = sum)

# Total tornadoes per state (not total for all states)
total_per_state <- tapply(td$mag_nam, td$st, FUN = length)

# Calculate fraction for each state
frac_ge3 <- (mag_greater_3 / total_per_state) * 100
frac_ge3
```
*Acknowledgement:*Took some inspiration from this code above generated by Chat-GPT for the correction of mine.

### With `dplyr`
```{r}
  library(dplyr)

  td %>%
    group_by(st) %>%
    reframe(
      "The fraction of tornadoes with magnitude >= 3 for each state" = sum(mag_nam >= 3), "Fraction " = (sum(mag_nam >=3)/sum(mag_nam))*100
    )
```

## Question 4
Write a function that takes a data frame as its argument and returns the slope coefficient in a linear model with loss (`loss`) as a linear function of magnitude (`mag`, coded as a number).
(Hint: the `coef` function will extract the coefficients from the output of the `lm` function.)

```{r}
  slope_coef <- function(td){
    linear_model <- lm(td$loss ~ td$mag_nam, data = td)
    return(coef(linear_model)["td$mag_nam"])
  }
  slope_coef(td)
```

## Question 5
Using the split/apply/combine strategy discussed in class and the function you wrote in the previous section, compute the slope in a linear model of loss as a function of magnitude for each state.

```{r}
  # Using split/apply/combine strategy
  by_state <- split(td, td$st)
  
  # Apply the slope_coef function to each subset
  state_slopes <- sapply(by_state, slope_coef)
  
  # Display the results
  state_slopes
  
  state_slopes <- lapply(by_state, slope_coef)
  # Display the results with `lapply`
  state_slopes
```

## Question 6
Notice that the coding for `loss` changes after 1996 (https://www.spc.noaa.gov/wcm/data/
SPC_severe_database_description.pdf), that `loss = 0` means unknown, and that `mag = -9` also means unknown. Split the analysis by pre/post-1996 in addition to state (so now there
should be two values for each state, one for pre-1996 and one for post-1996) and modify either the `dataset` or your function so that it does not include `loss = 0` or `mag = -9` in the calculations.

```{r}
  # Step 1: Create a 'year' variable and clean the data
  td$year <- as.numeric(substr(td$date, 1, 4))  # Assuming 'date' is in "YYYY-MM-DD" format
  
  # Exclude rows where loss = 0 or mag = -9
  td_clean <- td %>%
    filter(loss != 0, mag != -9)
  
  # Step 2: Create a new variable for pre/post-1996
  td_clean <- td_clean %>%
    mutate(period = ifelse(year < 1996, "Pre-1996", "Post-1996"))
  
  # Step 3: Define the slope calculation function
  slope_coef <- function(df){
    # If there's no data left for a subset, return NA immediately
    if (nrow(df) == 0) return(NA_real_)
    # Fit the linear model
    linear_model <- lm(loss ~ mag_nam, data = df)
    return(coef(linear_model)["mag_nam"])
  }
  
  # Step 4: Apply split/apply/combine by state and period
  by_state_year <- split(td_clean, list(td_clean$st, td_clean$period))
  
  # Apply the `slope_coef` function to each subset
  state_year_slopes <- sapply(by_state_year, slope_coef)
  
  # Step 5: Show the results
  state_year_slopes_df <- data.frame(state_year_slopes)
  
  
  # Print the results, sorted by slope value
  state_year_slopes_df
```

## Question 7
One might expect states that see strong tornadoes more often to build more defensively against hurricanes. To check this, merge the results in parts (3) and (6), and see if there is a correlation between the fraction of hurricanes with magnitude at least 3 and the increase in loss due to stronger hurricanes. Since you have pre- and post-1996 slopes for each state, you should do the analysis separately for each time period.

```{r}
  library(tidyr)
  
  # Convert the mag to numeric (done already)
  td$mag_nam <- as.numeric(td$mag)
  
  # Apply split/apply/combine strategy
  mag_greater_3 <- tapply(td$mag_nam >= 3, td$st, FUN = sum)
  
  # Total tornadoes per state (not total for all states)
  total_per_state <- tapply(td$mag_nam, td$st, FUN = length)
  
  # Calculate fraction for each state
  frac_ge3 <- (mag_greater_3 / total_per_state) * 100
  
  # Convert to data frame
  frac_ge3_df <- data.frame(
    st = names(frac_ge3),
    frac_ge3 = as.numeric(frac_ge3),
    row.names = NULL
  )
  
  # View the fraction data frame
  frac_ge3_df

  # Add state and period as separate columns
  state_year_slopes_df <- state_year_slopes_df %>%
    mutate(State_Period = rownames(state_year_slopes_df)) %>%
    separate (State_Period, into = c("st", "period"), sep = "\\.")
  
  # View the cleaned slopes data
  state_year_slopes_df

  # Merge the fraction of tornadoes with the slope data by state
  merged_df <- state_year_slopes_df %>%
    left_join(frac_ge3_df, by = "st")
  
  # View the merged data
  merged_df

  # Correlation for Pre-1996
  pre_1996_corr <- merged_df %>%
    filter(period == "Pre-1996")
  
  # Correlation for Post-1996
  post_1996_corr <- merged_df %>%
    filter(period == "Post-1996")
  
  # Display results
  pre_1996_corr
  post_1996_corr

```
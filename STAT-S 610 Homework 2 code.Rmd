---
title: "STAT-S 610 Homework 2 code"
author: "Nahid Hasan Sagar"
date: "2025-09-17"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Reading the files

```{r}
  ighv <- read.delim("C:/Users/nhsdu/OneDrive/Desktop/Career/MS at IU/STAT-S 610/Homeworks/Codes/HomeworkCodes/ighv.fasta", header = FALSE, stringsAsFactors = FALSE)
  ighv
```

## Answering questions

### What type of object is ighv?

```{r}
  str(ighv)
```
From the code output we can see this is a 'data.frame' object. Here if we use typeof() function then it doesn't give us much information other than telling us it's just a list. So, str() is more approprite function to know what ighv really is.

## What happens if you use header = TRUE instead of header = FALSE?

```{r}
  ighv <- read.delim("C:/Users/nhsdu/OneDrive/Desktop/Career/MS at IU/STAT-S 610/Homeworks/Codes/HomeworkCodes/ighv.fasta", header = TRUE, stringsAsFactors = FALSE)
  ighv
```

So, form the output we can see if we set header = TRUE then it treats the first row as the header for the data. If we use that in the analysis we will lose first row.

## Separating Descriptions and Sequences

```{r}
  ighv <- read.delim("C:/Users/nhsdu/OneDrive/Desktop/Career/MS at IU/STAT-S 610/Homeworks/Codes/HomeworkCodes/ighv.fasta", header = FALSE, stringsAsFactors = FALSE)

  descriptions <- ighv$V1[grepl("^>", ighv$V1)]
  descriptions
  
  sequences <- ighv$V1[!grepl("^>", ighv$V1)]
  sequences
```

Make a regular
expression that checks whether there are any letters aside from A, G, C, or T (the only valid
letters for a nucleotide sequence). Apply this to your vector of sequences to check whether
the sequences you extracted are valid.

## Validity Checking

###Sequences

```{r}
  is_valid <- grepl("^[AGCT]+$", sequences)
  is_valid
  
  invalid <- grepl("[^AGCT]", sequences)
  invalid
  
  cat("Total sequences:", length(sequences), "\n")
  cat("Valid sequences:", sum(is_valid), "\n")
  cat("Invalid sequences:", sum(invalid), "\n")
```

Since the length of the sequences and the sum of the valid sequences is equal, and the sum of the invalid sequences are 0. So, there's no invalid sequence present in the data.

### Descriptions

```{r}
  description_pattern <- "^>IGHV[0-9]-[0-9]{1,2}\\*[0-9]{2}$"
  is_valid_desc <- grepl(description_pattern, descriptions)
  is_valid_desc
  
  invalid_desc <- !is_valid_desc
  invalid_desc
  
  cat("Total description lenght:", length(descriptions), "\n")
  cat("Valid descriptions:", sum(is_valid_desc), "\n")
  cat("Invalid descriptions:", sum(invalid_desc), "\n")
```

So, we can see the length of the descriptions is 198 valid description length is 158 and invalid description length is 40. So, there are 40 invalid description.

## Checking for matches

```{r}
  # Checking which ones match
  matches <- grepl("[AT][CG][AT]", sequences)
  sequences[matches]  # Shows matching strings
  
  # Seeing all the results
  data.frame(string = sequences, matches = matches)
```

Modify the regular expression above so that it matches strings with at least five A/T followed by C/G followed by at least five A/Ts. Search for the regular expression in your
sequence vector using the grep function. How many sequences have that particular pattern?

### Checking for five string matches

```{r}
  pattern <- "[AT]{5,}[CG][AT]{5,}"
  
  # Searching for the pattern in sequences
  matches <- grep(pattern, sequences)
  
  # Counting how many sequences have this pattern
  length(matches)
  
  # Showing the sequences that match
  sequences[matches]
```

## Code with gregexpr:

```{r}
  # gregexpr finds all the matches in each sequence
  all_matches <- gregexpr(pattern, sequences)

  # Checking the type of output
  class(all_matches)
  typeof(all_matches)
```

### Exploring the structure:

```{r}
  # Looking at the structure
  str(all_matches[1:3])  # First 3 elements
  
  # Checking first sequence
  all_matches[[1]]  # Starting positions of matches in sequence 1
  attr(all_matches[[1]], "match.length")  # Lengths of matches
```

### Finding sequences with multiple matches:

```{r}
  # Counting matches per sequence
  match_counts <- sapply(all_matches, function(x) {
    if(x[1] == -1) {
      return(0)  # No matches
    } else {
      return(length(x))  # Number of matches
    }
  })
  
  # Checking results
  cat("Total sequences:", length(sequences), "\n")
  cat("Sequences with 0 matches:", sum(match_counts == 0), "\n")
  cat("Sequences with 1 match:", sum(match_counts == 1), "\n")
  cat("Sequences with >1 match:", sum(match_counts > 1), "\n")
  
  # Showing sequences with multiple matches
  multiple_matches <- which(match_counts > 1)
  if(length(multiple_matches) > 0) {
    cat("\nSequences with multiple matches:\n")
    for(i in multiple_matches) {
      cat("Sequence", i, "has", match_counts[i], "matches\n")
    }
  } else {
    cat("\nNo sequences have multiple matches\n")
  }
```

#### Acknowledgement: I used Claude Sonnet 4 for the overall homework on some syntax and how to design the code cleanly.